# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q03y2K2sFcZmK3-bMsjCFzLkfCWeoF9Y
"""

!pip install timm
!pip install opencv-python
!pip install matplotlib

import torch
import cv2
import numpy as np
import matplotlib.pyplot as plt
from torchvision.transforms import Compose
from google.colab import files

# Load MiDaS model and transform
midas = torch.hub.load("intel-isl/MiDaS", "DPT_Large")
midas.eval()
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
midas.to(device)

# Load transforms
midas_transforms = torch.hub.load("intel-isl/MiDaS", "transforms")
transform = midas_transforms.dpt_transform

print("üì§ Upload calibration image (plant at exactly 1 meter)...")
uploaded = files.upload()
calib_img_path = list(uploaded.keys())[0]

# Load and process calibration image
img = cv2.imread(calib_img_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
input_batch = transform(img_rgb).to(device)

with torch.no_grad():
    prediction = midas(input_batch)
    prediction = torch.nn.functional.interpolate(
        prediction.unsqueeze(1),
        size=img.shape[:2],
        mode="bicubic",
        align_corners=False,
    ).squeeze()

depth_map_calib = prediction.cpu().numpy()

# Get center pixel depth
center_x = img.shape[1] // 2
center_y = img.shape[0] // 2
depth_at_known = depth_map_calib[center_y, center_x]

print(f"‚úÖ Depth at center for calibration image (1m away): {depth_at_known:.4f}")

known_distance_m = 1.0  # meters
K = known_distance_m * depth_at_known
print(f"üìê Calibration constant K = {K:.4f}")

print("üì§ Upload actual plant image (unknown distance)...")
uploaded = files.upload()
test_img_path = list(uploaded.keys())[0]

# Load and process test image
img = cv2.imread(test_img_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
input_batch = transform(img_rgb).to(device)

with torch.no_grad():
    prediction = midas(input_batch)
    prediction = torch.nn.functional.interpolate(
        prediction.unsqueeze(1),
        size=img.shape[:2],
        mode="bicubic",
        align_corners=False,
    ).squeeze()

depth_map = prediction.cpu().numpy()

# Get center depth
center_x = img.shape[1] // 2
center_y = img.shape[0] // 2
depth_at_center = depth_map[center_y, center_x]

# Convert to real-world distance
real_distance_m = K / depth_at_center

# Display results
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.title("Test Image")
plt.imshow(img_rgb)
plt.plot(center_x, center_y, 'ro')
plt.axis("off")

plt.subplot(1, 2, 2)
plt.title("Estimated Depth Map")
plt.imshow(depth_map, cmap='inferno')
plt.plot(center_x, center_y, 'bo')
plt.axis("off")
plt.show()

print(f"üìç Center coordinates: X={center_x}, Y={center_y}")
print(f"üìè Estimated Real-World Distance: {real_distance_m:.2f} meters")